# Библиотека для обработки данных, полученных из аналогово-цифровых преобразователей *UNIT_NAME* компании "*COMPANY_NAME*"

## Дисклеймер

Данная библиотека разработана в процессе реверс-инжиниринга архивов, скопированных из внутренний памяти АЦП штатными средствами (путем втыкания флешки в USB-разъем, расположенный на АЦП). В наличии находится всего два АЦП, поэтому вполне допустимы какие-то ошибки, связанные с пониманием структуры архива в связи с недостаточно репрезентативной выборкой данных.

## Структура архива .AR4

Архив .AR4 представляет собой бинарный файл размером 67 109 120 байт, в котором данные структурированы в фрагментах по 256 байт. В первом фрагменте находится информация о самом приборе: серийный номер, дата создания архива и текстовое поле, с помощью которого можно идентифицировать конкретный прибор в других программах. В качестве примера рассмотрим первый фрагмент длиной в 256 байт одного из АЦП (для удобства восприятия байты сгруппированы):

```
6172 0001 0000 0004 0000 0000 0100 011d 0000 4a00 0106 5de8 485e 315c 4000 0000
0000 0000 0000 0000 0000 1053 5445 4e44 2020 2020 2020 2020 2020 2000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 3232 3232 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
```

Здесь можно выделить следующие последовательности:

1. Дата создания архива (когда в прибор воткнули флешку) содержится в последовательности с 23 по 26 байт. Байты хранятся в обратном порядке (Little-endian). В приведенном выше фрагменте это значение `0x5de8485e`, что можно декодировать в дату `05.10.2023 14:33:29` (алгоритм кодировки временных меток будет рассмотрен ниже);
2. Серийный номер прибора содержится в последовательности с 27 по 30 байт. Байты так же хранятся в обратном порядке (Little-endian). Значение `0x315c4000` соответсвует целому числу `4217905`;
3. Длина текствовой метки, которую можно присвоить прибору, содержится в 43 байте. В приведенном выше фрагменте значение этого байта составляет `0x10`, что соответствует 16 символам текствовой метки;
4. Tекстовая метка содержится в последовательности с 44 по 59 байт. Байты хранятся в прямом порядке (Big-endian). В приведенном выше фрагменте это значение `0x5354454e442020202020202020202020`, что в кодировке ASCII означает  '`STEND           `'. В кодировке ASCII код `0x20` является кодом пробельного символа.

После первого фрагмента байт идут фрагменты, по-видимому, содержащие служебную информацию. Эта часть архива не рассматривается в разрабатываемой библиотеке, так как представляется слишком трудозатратным декодировать эти данные. С другой стороны, сама структура фрагментов помогает понять, каким образом формируются записи а архиве. 

Второй фрагмент:

```
a54b ffff ffff 0000 ffff 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f
20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f
20ed 067f 20ed 067f 20ed f8a5 4bff ffff ff01 0000 103a 0f26 d900 0000 0039 0cd9
1f39 d830 84b9 8e1e 7839 0db1 9139 0d67 1e39 d279 7ab9 8cab 3c00 0000 0039 8f1b
81b9 9004 4606 9004 4600 0000 0000 0000 003a 3009 c116 a54b ffff ffff 0100 0000
390f 2765 0000 0000 0000 0000 b990 6b8b 398e 1e8a b90e 8855 0000 0000 b98c 52e5
0000 0000 0000 0000 0000 0000 0000 0000 b910 40ec 0000 0000 39d9 e8f5 b98d 00e7
8eff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff
```

Третий фрагмент:

```
a54b ffff ffff 0100 0000 0000 0000 39d4 771b b9d2 dc12 0000 0000 39d5 99db b9d4
f4fe b90e 4283 0000 0000 398c acb3 3990 06bb 390f 1c63 3990 03b9 b910 3abc b910
4b2a 3910 fd48 3a0c cc2f bba5 4bff ffff ff01 0000 00b9 8f27 f100 0000 0039 0c04
d1b9 106a fd39 0e20 d500 0000 00b9 8dd5 2db9 8c54 6e00 0000 0000 0000 00b9 0f1d
35b9 106c ce39 103d 22b9 90b6 5739 9100 4239 0cff d995 a54b ffff ffff 0100 0000
b98f 27ab 0000 0000 398c 7023 b910 6a60 390e 21b5 398d b06d b90d 6ae0 390c 53e7
39d3 038e 0000 0000 390f 1ca9 3990 0247 3910 3d22 b9d8 df89 b911 d90e 39d3 17af
a0ff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff 
```

Здесь уже отслеживается закономерность: оба фрагмента начинаются с последовательности байтов `0xa54b` и заканчиваются 31 байтом `0xff`. Очевидно, что в фрагмент не помещается целое число записей, поэтому остаток забивается байтами `0xff`, а новая запись попадает в следующий фрагмент. Значит, из 256 байт на записи остается 225 байт. В каждом фрагменте находится по три последовательности байтов `0xa54b`, при этом если предположить, что первый байт из этой последовательности `0xa5` означает начало записи, а второй байт `0x4b` - ее длину (десятичной системе счисления это число 75), то это как раз дает `3x75 = 225` байт.

Таким образом, второй и третий фрагменты примут следующий вид:

```
a54b ffff ffff 0000 ffff 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed 067f 20ed f8
a54b ffff ffff 0100 0010 3a0f 26d9 0000 0000 390c d91f 39d8 3084 b98e 1e78 390d b191 390d 671e 39d2 797a b98c ab3c 0000 0000 398f 1b81 b990 0446 0690 0446 0000 0000 0000 0000 3a30 09c1 16
a54b ffff ffff 0100 0000 390f 2765 0000 0000 0000 0000 b990 6b8b 398e 1e8a b90e 8855 0000 0000 b98c 52e5 0000 0000 0000 0000 0000 0000 0000 0000 b910 40ec 0000 0000 39d9 e8f5 b98d 00e7 8e
ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ff
a54b ffff ffff 0100 0000 0000 0000 39d4 771b b9d2 dc12 0000 0000 39d5 99db b9d4 f4fe b90e 4283 0000 0000 398c acb3 3990 06bb 390f 1c63 3990 03b9 b910 3abc b910 4b2a 3910 fd48 3a0c cc2f bb
a54b ffff ffff 0100 0000 b98f 27f1 0000 0000 390c 04d1 b910 6afd 390e 20d5 0000 0000 b98d d52d b98c 546e 0000 0000 0000 0000 b90f 1d35 b910 6cce 3910 3d22 b990 b657 3991 0042 390c ffd9 95
a54b ffff ffff 0100 0000 b98f 27ab 0000 0000 398c 7023 b910 6a60 390e 21b5 398d b06d b90d 6ae0 390c 53e7 39d3 038e 0000 0000 390f 1ca9 3990 0247 3910 3d22 b9d8 df89 b911 d90e 39d3 17af a0
ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ff
``` 

Как уже было указано выше, пока эти данные будут оставлены без внимания.

## Модуль ar4_parser.py

Класс **Ar4Parser** содержит методы, позволяющие декодировать архив формата **.AR4**, извлечь из него данные за заданный временной интервал, за указанную дату, за последнюю представленную в архиве дату или разбить архив на данные по датам.

## TODO:

1. Согласовать типы данных через mypy;
2. Реализовать прореживание данных;
3. Реализовать интерфейс командной строки;
4. Реализовать построение графиков по извлеченным данным.
